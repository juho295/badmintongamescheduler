<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Badminton Game Scheduler</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #f4f4f9;
            margin: 0;
            padding-top: 20px;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            height: 100vh;
        }

        .container {
            display: flex;
            justify-content: space-between;
            width: 80%;
            max-width: 1200px;
            background-color: #ffffff;
            border-radius: 8px;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.1);
            padding: 20px;
        }

        .left-panel, .right-panel {
            width: 48%;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .left-panel {
            text-align: center;
        }

        .right-panel {
            border-left: 1px solid #ddd;
            padding-left: 20px;
        }

        button {
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 10px;
            cursor: pointer;
            font-size: 16px;
        }

        button:hover {
            background-color: #45a049;
        }

        h1 {
            color: #333;
        }

        .input-group {
            margin: 10px 0;
        }

        label {
            font-weight: bold;
        }

        input {
            padding: 8px;
            font-size: 16px;
            width: 200px;
            margin: 5px 10px;
            text-align: center;
        }

        #scheduleOutput {
            margin-top: 20px;
            text-align: left;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }

        table, th, td {
            border: 1px solid #ddd;
        }

        th, td {
            padding: 10px;
            text-align: center;
        }

        th {
            background-color: #f2f2f2;
        }

        /* Pop-up styling */
        .popup {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .popup-content {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            width: 80%;
            max-width: 900px;
            overflow-y: auto;
        }

        .close-btn {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
        }

        .close-btn:hover {
            color: black;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="left-panel">
            <h1>Enter Player Names</h1>

            <div class="input-group">
                <label for="numCourts">Number of Courts:</label>
                <input type="number" id="numCourts" value="3" min="1" max="4">
            </div>

            <div class="input-group">
                <label for="numPlayers">Number of Players:</label>
                <input type="number" id="numPlayers" value="12" min="4" max="16">
            </div>

            <div id="playerInputs"></div>
        </div>

        <div class="right-panel">
            <h1>Badminton Game Schedule</h1>
            <button id="generateScheduleBtn">Generate Schedule</button>
            <button id="downloadScheduleBtn" style="display: none;">Download Schedule</button>
            <button id="showPopupBtn">Show Pairing Information</button>
            <div id="scheduleOutput"></div>
        </div>
    </div>

    <!-- Pop-up for pairing info -->
    <div id="popup" class="popup">
        <div class="popup-content">
            <span class="close-btn" id="closePopupBtn">&times;</span>
            <h2>Player Pairing Information</h2>

            <!-- Section for Players Repeated More Than 3 Times Against Same Opponent -->
            <h3>Players Repeated More Than 2 Times Against Same Opponent</h3>
            <table id="opponentTable">
                <thead>
                    <tr>
                        <th>Player</th>
                        <th>Opponent</th>
                        <th>Round(s)</th>
                    </tr>
                </thead>
                <tbody>
                    <!-- Populated dynamically -->
                </tbody>
            </table>

            <!-- Section for Players Repeated More Than 1 Time(s) With Same Partner -->
            <h3>Players Repeated More Than 2 Times With Same Partner</h3>
            <table id="partnerTable">
                <thead>
                    <tr>
                        <th>Player</th>
                        <th>Partner</th>
                        <th>Round(s)</th>
                    </tr>
                </thead>
                <tbody>
                    <!-- Populated dynamically -->
                </tbody>
            </table>
        </div>
    </div>

    <script>
const defaultPlayers = [
    "Player 1", "Player 2", "Player 3", "Player 4", "Player 5",
    "Player 6", "Player 7", "Player 8", "Player 9", "Player 10",
    "Player 11", "Player 12", "Player 13", "Player 14", "Player 15", "Player 16"
];

let currentSchedule = [];
const MAX_ATTEMPTS = 100; // Maximum attempts to generate a valid schedule
const MAX_PAIR_ATTEMPTS = 50; // Maximum attempts to find valid pairs for a round

function generateSchedule(numPlayers, numCourts, players) {
    const rounds = 9;
    let bestSchedule = null;
    let bestScore = Infinity;

    // Try multiple times to get the best possible schedule
    for (let attempt = 0; attempt < MAX_ATTEMPTS; attempt++) {
        const schedule = [];
        const pairHistory = new Map(); // Track how often players have played together
        let isValid = true;

        for (let round = 1; round <= rounds; round++) {
            const roundResult = generateRound(players, numCourts, pairHistory, round);

            if (!roundResult) {
                isValid = false;
                break;
            }

            updatePairHistory(roundResult, pairHistory);
            schedule.push(roundResult);
        }

        if (isValid) {
            const score = evaluateSchedule(schedule, pairHistory);
            if (score < bestScore) {
                bestScore = score;
                bestSchedule = schedule;
            }
        }
    }

    return bestSchedule || []; // Return best schedule or empty array if none found
}

function generateRound(players, numCourts, pairHistory, roundNum) {
    let attempts = 0;
    while (attempts < MAX_PAIR_ATTEMPTS) {
        const availablePlayers = [...players];
        const roundMatches = [];
        shuffle(availablePlayers);

        let success = true;
        for (let court = 1; court <= numCourts && availablePlayers.length >= 4; court++) {
            const match = findValidMatch(availablePlayers, pairHistory);
            if (!match) {
                success = false;
                break;
            }
            match.round = roundNum;
            match.court = court;
            roundMatches.push(match);
        }

        if (success && roundMatches.length > 0) {
            return roundMatches;
        }
        attempts++;
    }
    return null;
}

function findValidMatch(availablePlayers, pairHistory) {
    if (availablePlayers.length < 4) return null;

    // Try to find valid teams with the least history together
    let bestMatch = null;
    let bestScore = Infinity;

    for (let i = 0; i < Math.min(10, availablePlayers.length); i++) {
        for (let j = i + 1; j < Math.min(11, availablePlayers.length); j++) {
            for (let k = j + 1; k < Math.min(12, availablePlayers.length); k++) {
                for (let l = k + 1; l < Math.min(13, availablePlayers.length); l++) {
                    const team1 = [availablePlayers[i], availablePlayers[j]];
                    const team2 = [availablePlayers[k], availablePlayers[l]];

                    const score = evaluateMatch(team1, team2, pairHistory);
                    if (score < bestScore) {
                        bestScore = score;
                        bestMatch = { team1, team2 };
                    }
                }
            }
        }
    }

    if (bestMatch) {
        // Remove selected players from available players
        [...bestMatch.team1, ...bestMatch.team2].forEach(player => {
            const index = availablePlayers.indexOf(player);
            if (index > -1) {
                availablePlayers.splice(index, 1);
            }
        });
    }

    return bestMatch;
}

function evaluateMatch(team1, team2, pairHistory) {
    let score = 0;
    // Evaluate partner history
    score += getPartnerHistory(team1[0], team1[1], pairHistory) * 10;
    score += getPartnerHistory(team2[0], team2[1], pairHistory) * 10;

    // Evaluate opponent history
    for (const player1 of team1) {
        for (const player2 of team2) {
            score += getOpponentHistory(player1, player2, pairHistory) * 8;
        }
    }
    return score;
}

function getPartnerHistory(player1, player2, pairHistory) {
    const key = [player1, player2].sort().join('-');
    return pairHistory.get(key)?.partner || 0;
}

function getOpponentHistory(player1, player2, pairHistory) {
    const key = [player1, player2].sort().join('-');
    return pairHistory.get(key)?.opponent || 0;
}

function updatePairHistory(roundMatches, pairHistory) {
    roundMatches.forEach(match => {
        // Update partner history
        updatePairCount(match.team1[0], match.team1[1], pairHistory, 'partner');
        updatePairCount(match.team2[0], match.team2[1], pairHistory, 'partner');

        // Update opponent history
        for (const player1 of match.team1) {
            for (const player2 of match.team2) {
                updatePairCount(player1, player2, pairHistory, 'opponent');
            }
        }
    });
}

function updatePairCount(player1, player2, pairHistory, type) {
    const key = [player1, player2].sort().join('-');
    if (!pairHistory.has(key)) {
        pairHistory.set(key, { partner: 0, opponent: 0 });
    }
    const count = pairHistory.get(key);
    count[type]++;
}

function evaluateSchedule(schedule, pairHistory) {
    let score = 0;
    pairHistory.forEach((count) => {
        if (count.partner > 2) score += Math.pow(count.partner - 2, 2) * 100;
        if (count.opponent > 3) score += Math.pow(count.opponent - 3, 2) * 80;
    });
    return score;
}

function shuffle(array) {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    }
}

function displaySchedule(schedule) {
    const scheduleOutput = document.getElementById("scheduleOutput");
    scheduleOutput.innerHTML = "";

    let scheduleText = "Badminton Game Scheduler\n\n";

    schedule.forEach(round => {
        const roundTitle = document.createElement("h3");
        roundTitle.textContent = `Round ${round[0].round}`;
        scheduleOutput.appendChild(roundTitle);
        scheduleText += `Round ${round[0].round}\n`;

        const roundTable = document.createElement("table");
        const roundHeader = document.createElement("tr");
        roundHeader.innerHTML = `<th>Round</th><th>Court</th><th>Players (Team 1)</th><th>Players (Team 2)</th>`;
        roundTable.appendChild(roundHeader);

        round.forEach(match => {
            const matchRow = document.createElement("tr");
            matchRow.innerHTML = `
                <td>${match.round}</td>
                <td>${match.court}</td>
                <td class="team1">${match.team1.join(" & ")}</td>
                <td class="team2">${match.team2.join(" & ")}</td>
            `;
            roundTable.appendChild(matchRow);
        });

        scheduleOutput.appendChild(roundTable);
        scheduleText += roundTable.innerText + "\n";
    });

    const downloadBtn = document.getElementById("downloadScheduleBtn");
    downloadBtn.style.display = "inline-block";

    downloadBtn.onclick = function() {
        const blob = new Blob([scheduleText], { type: "text/plain" });
        const link = document.createElement("a");
        link.href = URL.createObjectURL(blob);
        link.download = "badminton_schedule.txt";
        link.click();
    };
}

function getPlayerPairingInfo(schedule) {
    let playerOpponentCount = {};
    let playerPartnerCount = {};
    let opponentInstances = {};
    let partnerInstances = {};

    schedule.forEach(round => {
        round.forEach(match => {
            [match.team1, match.team2].forEach(team => {
                team.forEach(player => {
                    if (!playerOpponentCount[player]) playerOpponentCount[player] = {};
                    if (!playerPartnerCount[player]) playerPartnerCount[player] = {};

                    // Count opponents
                    const opponents = team === match.team1 ? match.team2 : match.team1;
                    opponents.forEach(opponent => {
                        playerOpponentCount[player][opponent] = (playerOpponentCount[player][opponent] || 0) + 1;
                    });

                    // Count partners
                    team.forEach(partner => {
                        if (partner !== player) {
                            playerPartnerCount[player][partner] = (playerPartnerCount[player][partner] || 0) + 1;
                        }
                    });
                });
            });
        });
    });

    // Find instances of players with same opponents more than 2 times
    for (let player in playerOpponentCount) {
        for (let opponent in playerOpponentCount[player]) {
            if (playerOpponentCount[player][opponent] > 2) {
                if (!opponentInstances[player]) opponentInstances[player] = [];
                opponentInstances[player].push(opponent);
            }
        }
    }

    // Find instances of players with same partners more than 1 times
    for (let player in playerPartnerCount) {
        for (let partner in playerPartnerCount[player]) {
            if (playerPartnerCount[player][partner] > 1) {
                if (!partnerInstances[player]) partnerInstances[player] = [];
                partnerInstances[player].push(partner);
            }
        }
    }
    return { opponentInstances, partnerInstances };
}

function displayPairingInfo(pairingInfo) {
    const opponentTableBody = document.getElementById("opponentTable").getElementsByTagName('tbody')[0];
    const partnerTableBody = document.getElementById("partnerTable").getElementsByTagName('tbody')[0];

    opponentTableBody.innerHTML = "";
    partnerTableBody.innerHTML = "";

    // Display opponent instances with round numbers
    for (let player in pairingInfo.opponentInstances) {
        pairingInfo.opponentInstances[player].forEach(opponent => {
            const row = opponentTableBody.insertRow();
            row.insertCell(0).textContent = player;
            row.insertCell(1).textContent = opponent;
            row.insertCell(2).textContent = getRoundsForOpponent(player, opponent);
        });
    }

    // Display partner instances with round numbers
    for (let player in pairingInfo.partnerInstances) {
        pairingInfo.partnerInstances[player].forEach(partner => {
            const row = partnerTableBody.insertRow();
            row.insertCell(0).textContent = player;
            row.insertCell(1).textContent = partner;
            row.insertCell(2).textContent = getRoundsForPartner(player, partner);
        });
    }
}

function getRoundsForOpponent(player, opponent) {
    let rounds = [];
    currentSchedule.forEach(round => {
        round.forEach(match => {
            if (match.team1.includes(player) && match.team2.includes(opponent)) {
                rounds.push(match.round);
            }
            if (match.team2.includes(player) && match.team1.includes(opponent)) {
                rounds.push(match.round);
            }
        });
    });
    return rounds.join(", ");
}

function getRoundsForPartner(player, partner) {
    let rounds = [];
    currentSchedule.forEach(round => {
        round.forEach(match => {
            if (match.team1.includes(player) && match.team1.includes(partner)) {
                rounds.push(match.round);
            }
            if (match.team2.includes(player) && match.team2.includes(partner)) {
                rounds.push(match.round);
            }
        });
    });
    return rounds.join(", ");
}

function getCustomPlayerNames(numPlayers) {
    const customPlayers = [];
    for (let i = 0; i < numPlayers; i++) {
        const playerInput = document.getElementById(`player${i + 1}`).value;
        customPlayers.push(playerInput || defaultPlayers[i]);
    }
    return customPlayers;
}

function generatePlayerInputs(numPlayers) {
    const playerInputsContainer = document.getElementById("playerInputs");
    playerInputsContainer.innerHTML = "";

    for (let i = 0; i < numPlayers; i++) {
        const playerInputGroup = document.createElement("div");
        playerInputGroup.className = "input-group";
        playerInputGroup.innerHTML = `
            <label for="player${i + 1}">Player ${i + 1}:</label>
            <input type="text" id="player${i + 1}" value="${defaultPlayers[i]}" />
        `;
        playerInputsContainer.appendChild(playerInputGroup);
    }
}

// Event Listeners
document.getElementById("generateScheduleBtn").addEventListener("click", () => {
    const numPlayers = parseInt(document.getElementById("numPlayers").value);
    const numCourts = parseInt(document.getElementById("numCourts").value);
    const customPlayers = getCustomPlayerNames(numPlayers);
    const schedule = generateSchedule(numPlayers, numCourts, customPlayers);
    currentSchedule = schedule;
    displaySchedule(schedule);
});

document.getElementById("showPopupBtn").addEventListener("click", () => {
    const playerPairingInfo = getPlayerPairingInfo(currentSchedule);
    displayPairingInfo(playerPairingInfo);
    document.getElementById("popup").style.display = "flex";
});

document.getElementById("closePopupBtn").addEventListener("click", () => {
    document.getElementById("popup").style.display = "none";
});

document.getElementById("numPlayers").addEventListener("change", (e) => {
    generatePlayerInputs(parseInt(e.target.value));
});

// Initialize player inputs
generatePlayerInputs(parseInt(document.getElementById("numPlayers").value));
    </script>
</body>
</html>
